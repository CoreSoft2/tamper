#!/usr/bin/env python
import sys
import struct
import os
import threading
import json
import re
import urllib2
import uuid
import Queue
from netlib.odict import ODictCaseless
from subprocess import call
from libmproxy import proxy, flow
from libmproxy.protocol.http import HTTPResponse
from libmproxy.proxy.config import ProxyConfig
from libmproxy.proxy.server import ProxyServer
from libmproxy.encoding import decode_gzip

# sharedVars = {}
urlsToProxy = []

def send_message(message):
    message = '{"msg": %s}' % message
    sys.stdout.write(struct.pack('I', len(message)))
    sys.stdout.write(message)
    sys.stdout.flush()

def open_editor(filename):
    if os.name == 'nt':
        os.startfile(filename)
    else:
        call(['subl', filename])

# Thread that reads messages from the webapp.
def read_thread_func(queue):
    message_number = 0
    while 1:
        # Read the message length (first 4 bytes).
        text_length_bytes = sys.stdin.read(4)

        if len(text_length_bytes) == 0:
            if queue:
                queue.put(None)
            sys.exit(0)

        # Unpack message length as 4 byte integer.
        text_length = struct.unpack('i', text_length_bytes)[0]

        # Read the text (JSON object) of the message.
        text = sys.stdin.read(text_length).decode('utf-8')

        message = json.loads('%s' % text)

        if message == None:
            send_message(json.dumps({'method': 'log', 'message': 'Disconnected'}))
        else:


            if (message['method'] == 'hello'):
                send_message(json.dumps({'method': 'hello'}))

            elif (message['method'] == 'update-rules'):
                while len(urlsToProxy):
                    urlsToProxy.pop()

                for rule in message['rules']:
                    urlsToProxy.append(rule)

                send_message(json.dumps(message))

            elif (message['method'] == 'open-file'):
                open_editor(os.path.dirname(os.path.realpath(__file__)) + '/replacements/' + message['filename'])
                send_message(json.dumps(message))

            elif (message['method'] == 'cache-response'):
                urlFilename = message['filename']
                while True:
                    filename = str(uuid.uuid1()) + '.' + urlFilename
                    fullFilePath = os.path.dirname(os.path.realpath(__file__)) + '/replacements/' + filename
                    if not os.path.isfile(fullFilePath):
                        break

                localFile = open(fullFilePath, 'w')
                localFile.write(message['responseContent'].encode('utf8'))
                localFile.close()

                # send_message(json.dumps({'method': 'rule-added', 'rule': rule}))
                message['cachedFilename'] = filename
                send_message(json.dumps(message))


class InjectingMaster(flow.FlowMaster):
    def __init__(self, server, state):
        flow.FlowMaster.__init__(self, server, state)

        relPath = os.path.dirname(os.path.realpath(__file__)) + '/'

        _requestMapFile = open(config['requestMapPath'], 'r+')
        # requestMap = json.load(_requestMapFile)['rules']
        self._cachedFilesPath = relPath + 'replacements/'
        while len(urlsToProxy):
            urlsToProxy.pop()

        # sharedVars['rules'] = [];

        # for url in requestMap:
        #     urlsToProxy.append(url)
        #     sharedVars['rules'].append(url)


    def run(self):
        try:
            return flow.FlowMaster.run(self)
        except KeyboardInterrupt:
            self.shutdown()

    def handle_request(self, msg):
        f = flow.FlowMaster.handle_request(self, msg)

        fullURL = f.request.scheme + '://' + f.request.host
        if ((f.request.scheme == 'http' and f.request.port == 80) or (f.request.scheme == 'https' and f.request.port == 443) == False):
            fullURL = fullURL + ':' + str(f.request.port)
        fullURL = fullURL + f.request.path

        send_message(json.dumps({'method': 'log', 'message': fullURL}))
        for url in urlsToProxy:
            if (url['url'] == fullURL and url['isEnabled'] == True):
                send_message(json.dumps({'method': 'log', 'message': 'Serving cached file (' + url['cachedFilename'] + ')'}))
                localFile = open(self._cachedFilesPath + url['cachedFilename'], 'r');
                content = localFile.read()
                localFile.close();                

                responseHeaders = []
                hasViaHeader = False
                for header in url['responseHeaders']:
                    if (header['name'].lower() != 'content-encoding'):
                        if (header['name'].lower() == 'via'):
                            hasViaHeader = True
                            if (header['value'].find('chrome-proxy') == -1):
                                header['value'] += ', chrome-proxy'

                        responseHeaders.append((header['name'], header['value']))

                if (not hasViaHeader):
                    responseHeaders.append(['via', 'chrome-proxy'])

                resp = HTTPResponse([1,1], 200, 'OK', ODictCaseless(responseHeaders), content)
                msg.reply(resp)
                break


        if 'Accept-Encoding' in f.request.headers:
            f.request.headers['Accept-Encoding'] = ['none']

        if f:
            msg.reply()

        return f

    def handle_responseheaders(self, f):
        f.response.stream = True

        f.reply()
        return f

    def handle_response(self, msg):
        f = flow.FlowMaster.handle_response(self, msg)

        if f:
            msg.reply()

        return f

config = {}

def save_request_map():
    requestMapFile = open(config['requestMapPath'], 'r+')
    requestMapFile.seek(0)
    requestMapFile.truncate()
    json.dump({'rules': urlsToProxy}, requestMapFile, sort_keys=True, indent=4)
    requestMapFile.close()

def main(argv):
    proxyConfig = proxy.config.ProxyConfig(
        port = 8889
    )

    relPath = os.path.dirname(os.path.realpath(__file__)) + '/'
    config['requestMapPath'] = relPath + 'requestmap.json'

    if not os.path.isdir(relPath + 'replacements/'):
        os.mkdir(relPath + 'replacements/')

    if not os.path.exists(config['requestMapPath']):
        f = open(config['requestMapPath'],'w')
        f.write('{"rules": []}')
        f.close()


    queue = Queue.Queue()
    thread = threading.Thread(target=read_thread_func, args=(queue,))
    thread.daemon = True
    thread.start()

    state = flow.State()
    server = proxy.server.ProxyServer(proxyConfig)

    m = InjectingMaster(server, state)
    m.run()

if __name__ == '__main__':
    main(sys.argv)
