#!/usr/bin/env python
import sys
import struct
import os
import threading
import json
import re
import urllib2
import uuid
import Queue
from netlib.odict import ODictCaseless
from subprocess import call
from libmproxy import proxy, flow
from libmproxy.protocol.http import HTTPResponse
from libmproxy.proxy.config import ProxyConfig
from libmproxy.proxy.server import ProxyServer
from libmproxy.encoding import decode_gzip

sharedVars = {}
urlsToProxy = []

def send_message(message):
    message = '{"msg": %s}' % message
    sys.stdout.write(struct.pack('I', len(message)))
    sys.stdout.write(message)
    sys.stdout.flush()

def open_editor(filename):
    if os.name == 'nt':
        os.startfile(filename)
    else:
        call(['open', filename])

# Thread that reads messages from the webapp.
def read_thread_func(queue):
    message_number = 0
    while 1:
        # Read the message length (first 4 bytes).
        text_length_bytes = sys.stdin.read(4)

        if len(text_length_bytes) == 0:
            if queue:
                queue.put(None)
            sys.exit(0)

        # Unpack message length as 4 byte integer.
        text_length = struct.unpack('i', text_length_bytes)[0]

        # Read the text (JSON object) of the message.
        text = sys.stdin.read(text_length).decode('utf-8')

        message = json.loads('%s' % text)

        if message == None:
            send_message(json.dumps({'method': 'log', 'message': 'Disconnected'}))
        else:
            if (message['method'] == 'rule-list'):
                send_message(json.dumps({'method': 'rule-list', 'rules': urlsToProxy}))

            if (message['method'] == 'hello'):
                send_message(json.dumps({'method': 'hello'}))

            elif (message['method'] == 'add-rule'):
                send_message(json.dumps({'method': 'log', 'message': 'adding rule'}))
                ruleAlreadyAdded = False

                for url in urlsToProxy:
                    if (url['url'] == message['url']):
                        if (url['isLoaded'] == True):
                            fullFilePath = os.path.dirname(os.path.realpath(__file__)) + '/replacements/' + url['cachedFilename']
                            call(['subl', fullFilePath])
                        ruleAlreadyAdded = True

                        send_message(json.dumps({'method': 'rule-updated', 'url': message['url']}))

                if not ruleAlreadyAdded:
                    send_message(json.dumps({'method': 'log', 'message': 'Adding rule for: ' + message['url']}))

                    # TODO guess file ext by Content-Type
                    regExpRes = re.search('.*\/(.*)', message['url'])
                    if (not regExpRes or regExpRes.group(1) == ''):
                        urlFilename = '.chromeproxy'
                    else:
                        urlFilename = '.' + regExpRes.group(1)
                        if (urlFilename.find('?') > -1):
                            urlFilename = urlFilename[:urlFilename.find('?')]
                        if urlFilename == '.':
                            urlFilename = '.chromeproxy'

                    while True:
                        filename = str(uuid.uuid1()) + urlFilename
                        fullFilePath = os.path.dirname(os.path.realpath(__file__)) + '/replacements/' + filename
                        if not os.path.isfile(fullFilePath):
                            break

                    localFile = open(fullFilePath, 'w')
                    localFile.write(message['responseContent'].encode('utf8'))
                    localFile.close()

                    call(['subl', fullFilePath])
                    rule = {
                        'isEnabled': True,
                        'isLoaded': True,
                        'url': message['url'],
                        'responseHeaders': message['responseHeaders'],
                        'cachedFilename': filename
                    }

                    urlsToProxy.append(rule)

                    send_message(json.dumps({'method': 'rule-added', 'rule': rule}))
                    save_request_map()

            elif (message['method'] == 'remove-rule'):
                for url in urlsToProxy:
                    if (url['url'] == message['url']):
                        urlsToProxy.remove(url)
                        send_message(json.dumps({'method': 'log', 'message': 'Removing rule for: ' + message['url']}))
                        
                        send_message(json.dumps({'method': 'rule-removed', 'rule': url}))
                        save_request_map();
                        break

            elif (message['method'] == 'udpate-rule'):
                for url in urlsToProxy:
                    if (url['url'] == message['url']):
                        url['isEnabled'] = message['isEnabled']
                        send_message(json.dumps({'method': 'log', 'message': 'Updating rule for: ' + message['url']}))

                        send_message(json.dumps({'method': 'rule-updated', 'rule': url}))
                        save_request_map();
                        break

class InjectingMaster(flow.FlowMaster):
    def __init__(self, server, state):
        flow.FlowMaster.__init__(self, server, state)

        relPath = os.path.dirname(os.path.realpath(__file__)) + '/'

        _requestMapFile = open(config['requestMapPath'], 'r+')
        requestMap = json.load(_requestMapFile)['rules']
        self._cachedFilesPath = relPath + 'replacements/'
        while len(urlsToProxy):
            urlsToProxy.pop()

        sharedVars['rules'] = [];

        for url in requestMap:
            urlsToProxy.append(url)
            sharedVars['rules'].append(url)


    def run(self):
        try:
            return flow.FlowMaster.run(self)
        except KeyboardInterrupt:
            self.shutdown()

    def handle_request(self, msg):
        f = flow.FlowMaster.handle_request(self, msg)

        send_message(json.dumps({'method': 'log', 'message': f.request.scheme + '://' + f.request.host + f.request.path}))
        for url in urlsToProxy:
            if (url['url'] == f.request.scheme + '://' + f.request.host + f.request.path and url['isEnabled'] == True):
                send_message(json.dumps({'method': 'log', 'message': 'Serving cached file (' + url['cachedFilename'] + ')'}))
                localFile = open(self._cachedFilesPath + url['cachedFilename'], 'r');
                content = localFile.read()
                localFile.close();                

                # resp = HTTPResponse([1,1], 200, 'OK', ODictCaseless([['Content-Type', url['contentType']], ['via', 'chrome-proxy']]), content)
                responseHeaders = []
                hasViaHeader = False
                for header in url['responseHeaders']:
                    if (header['name'].lower() != 'content-encoding'):
                        if (header['name'].lower() == 'via'):
                            hasViaHeader = True
                            if (header['value'].find('chrome-proxy') == -1):
                                header['value'] += ', chrome-proxy'

                        responseHeaders.append((header['name'], header['value']))

                if (not hasViaHeader):
                    responseHeaders.append(['via', 'chrome-proxy'])

                # responseHeaders = filter((lambda header: header['name'] != 'Content-Encoding'), url['responseHeaders'])
                # responseHeaders = map((lambda header: (header['name'], header['value'])), responseHeaders)
                resp = HTTPResponse([1,1], 200, 'OK', ODictCaseless(responseHeaders), content)
                msg.reply(resp)
                break


        if 'Accept-Encoding' in f.request.headers:
            f.request.headers['Accept-Encoding'] = ['none']

        if f:
            msg.reply()

        return f

    def handle_responseheaders(self, f):
        # f = resp.flow

        isURLRequested = False
        for url in urlsToProxy:
            if (url['url'] == f.request.scheme + '://' + f.request.host + f.request.path and url['isLoaded'] == False):
                isURLRequested = True

        if not isURLRequested:
            f.response.stream = True

        f.reply()
        return f

    def handle_response(self, msg):
        f = flow.FlowMaster.handle_response(self, msg)

        if f:
            msg.reply()

        return f

config = {}

def save_request_map():
    requestMapFile = open(config['requestMapPath'], 'r+')
    requestMapFile.seek(0)
    requestMapFile.truncate()
    json.dump({'rules': urlsToProxy}, requestMapFile, sort_keys=True, indent=4)
    requestMapFile.close()

def main(argv):
    proxyConfig = proxy.config.ProxyConfig(
        port = 8889
    )

    relPath = os.path.dirname(os.path.realpath(__file__)) + '/'
    config['requestMapPath'] = relPath + 'requestmap.json'

    if not os.path.isdir(relPath + 'replacements/'):
        os.mkdir(relPath + 'replacements/')

    if not os.path.exists(config['requestMapPath']):
        f = open(config['requestMapPath'],'w')
        f.write('{"rules": []}')
        f.close()


    queue = Queue.Queue()
    thread = threading.Thread(target=read_thread_func, args=(queue,))
    thread.daemon = True
    thread.start()
    # call(['subl', '/'])

    state = flow.State()
    server = proxy.server.ProxyServer(proxyConfig)

    m = InjectingMaster(server, state)
    m.run()

if __name__ == '__main__':
    main(sys.argv)
